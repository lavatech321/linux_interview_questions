\textbf{User and Group Administration}

\begin{enumerate}
    \item \textbf {What is a user?}
    \newline
    Ans. In Linux user is one who uses the system. 

	\bigskip
	\bigskip
    
    \item \textbf {How many types of users available in Linux?}
    \newline
    Ans.There are 5 types of users available in Linux.
    \begin{itemize}
	    \item System user   (Admin user who control the whole system nothing but root user).
	    \item Normal user  (Created by the Super user. In RHEL - 7 the user id's from 1000 - 60000).
	    \item System user   (Created when application or software installed 
	    \item In RHEL - 7 the System users are
	    Static system user id's from 1 - 200 and
	    (ii) Dynamic system user user id'sfrom 201 - 999).
	    \item Network user   (Nothing but remote user, ie., who are login to the system trough network  created
	    \item Windows Active Directory or in Linux LDAP or NIS). 
	    \item Sudo user   (The normal users who are having admin or Super user privileges)
    \end{itemize}

    
    \bigskip
    \bigskip
    
    \item \textbf { What is user management?}
    \newline
    Ans.User management means managing user. ie., Creating the users, deleting the users and modifying the users.
    
    \bigskip
    \bigskip
    
    \item \textbf{What are the important points related to users?}
    \begin {itemize}
	    \item Ans.Users and groups are used to control access to files and resources.
	    \item Users can login to the system by supplying username and passwords to the system.
	    \item Every file on the system is owned by a user and associated with a group.
	    \item Every process has an owner and group affiliation.
	    \item Every user in the system is assigned a unique user id (uid) and group id (gid).
	    \item User names and user id are stored in  /etc/passwd file.
	    \item User's passwords are stored in  /etc/shadow  file in an encrypted form.
	    \item Users are assigned a home directory and a shell to work with the O/S.
	    \item Users cannot read, write and execute each other's files without permission.
	    \item Whenever a user is created a mail box is created automatically in /var/spool/mail location.
	    \item And some user environmental files like  .bash\_logout,  .bash\_profile,  .bashrc ,  ...etc., are also copied from /etc/skell   to  his/her home directory (/home/<username>).
	\end{itemize}    
    
    \bigskip
    \bigskip

    \item \textbf{What are fields available in  /etc/passwd file?}
    \newline
    Ans.<user name>   :   x   :   <uid>   :   <gid>   :   <comment>   :
         <user's home directory>  :   <login shell
         (where   'x'   means link to password file ie.,  /etc/shadow   file)

    \bigskip
    \bigskip

    \item \textbf {What are fields available in  /etc/shadow  file?}
    \newline
    Ans. user name : password : last changed : min. days : max. days : warn days : inactive days : expiry days : reserved  for future.

    \bigskip
    \bigskip

    \item\textbf {What are the files that are related to user management?}
    \begin {itemize}
	    \item Ans.\textbf{/etc/passwd}: Stores user's information like user name, uid, home directory and shell ...etc.,
	    \item \textbf{/etc/shadow}: Stores user's password in encrypted form and other information.
	    \item \textbf{/etc/group}: Stores group's information like group name, gid and other information.
	    \item \textbf{/etc/gshadow}: Stores group's password in encrypted form.
	    \item \textbf{/etc/passwd}: Stores the  /etc/passwd   file backup copy.
	    \item \textbf{/etc/shadow}: Stores the /etc/shadow  file backup copy.
	    \item \textbf{/etc/default/useradd}: Whenever the user created user's default settings taken from this file.
	    \item \textbf{/etc/login.defs}: user's login defaults settings information taken from this file.
	    \item \textbf{/etc/skell}: Stores user's all environmental variables files and these are copied from this directory to user's home directory
    \end{itemize}

    \bigskip
    \bigskip

    \item \textbf {In how many ways can we create the users?}
    \begin{itemize}
	    \item Ans. \textbf{useradd} - <options><user name>
	    \item (ii)  \textbf{adduser}    - <options><user name>
	    \item (iii) \textbf{newusers}    <file name>   (In this file we have to enter the user details same as /etc/passwd   file)
    \end{itemize}

    \bigskip
    \bigskip

    \item\textbf{What is the syntax of useradd command with full options?}
    \newline
     Ans. useradd  -u <uid>  -g <gid>  -G <secondary group> -c  <comment>  -d <home 
        directory> -s <shell><user name> 
        \newline
        \textbf{Example:} useradd  -u  600  -g  600  -G  java   -c  "oracle user"   -d  /home/raju   -s /bin/bash raju

    \bigskip
    \bigskip

    \item\textbf {What is the syntax of adduser  command with full options?}
    \newline
     Ans.adduser  -u <uid>  -g <gid>  -G <secondary group> -c  <comment>  -d <home
    directory> -s <shell><user name>
    \newline
    \textbf{Example}\# adduser  -u  700  -g  700  -G  linux   -c  "oracle user"   -d  /home/ram   -s
    /bin/bash ram.

    \bigskip
    \bigskip
    
    \item\textbf{What is the syntax of newuser command?}
    \begin{itemize}
        \item Ans. newusers   <file name>	(This command will create multiple users at a time)
        \item First we should a file and enter user's data as fields same as the fields of /etc/passwd file for how many users do you want to create and mention that file as an argument for newusers command.
        \item When we execute this command new users will be created but their environmental files like        
    \end{itemize}  
        \textbf{.bash\_logout, .bash\_profile, .bashrc and .bash\_history}  files will not be copied from /etc/skell.
         Directory. So, we have to  copied manually from  /etc/skell   directory.

     \bigskip
     \bigskip
     
     \item\textbf{What is the syntax of userdel command with full options?}
     \newline
      Ans.userdel <options><user name>
      \newline
      The options are:
      \begin{itemize}
          \item \textbf{-f} :forcefully delete the user even through the user is login. The user's home directory, mail and message directories are also deleted. 
          \item \textbf{-r} : recursively means files in the user's home directory will be deleted and  his  home directory also deleted but the other files belongs to that user should be   deleted manually.
	  \end{itemize}
    \bigskip
    \bigskip

    \item\textbf{How to check whether user is already created or not?}
    \newline
     Ans.We can check in different ways:
     \begin{itemize}
     	\item id   <user name>   (It shows the user id group id and user name if that is already created)
     	\item grep <user name> /etc/passwd
     \end{itemize}
         
    \bigskip
    \bigskip
    
    \item\textbf{How to verify or check the integrity of the password file?}
    \newline
     Ans.\textbf{pwck}  <options>   /etc/passwd    or
    \newline
        \textbf{pwck} <options>   /etc/shadow 
        The options are,  \begin{itemize}
                            \item \textbf{-q} :quiet
                            \item \textbf{r }: read only	
                            \item \textbf{s }: sort the contents by uidin /etc/passwd and  /etc/shadow  files
                          \end{itemize}

    \bigskip
    \bigskip

    \item\textbf{How to verify or check the integrity of the group file?}
     \begin{itemize}
        \item grpck   <options>   /etc/group    or
        \item grpck   <options>   /etc/gshadow 
        \item The options are,    \textbf{-r}-r:read only
                                  \textbf{-s}:sort the contents by  \textbf{gidin  /etc/group   and   /etc/gshadow files.}
     \end{itemize}

    \bigskip  
    \bigskip
    
    \item\textbf{What is syntax of the usermod command with full options?}
    \newline
    Ans. usermod   <options><user name>
        The options are,        \begin{itemize}
                                  \item  -L:lock the password
                                  \item -U : unlock the password
                                  \item -o :creates duplicate user modify the user's  id  same as other user
                                  \item -u :modify user id
                                  \item -g : modify group id
                                  \item -G : modify   or  add  the  secondary group
                                  \item -c : modify comment
                                  \item -d : modify home directory
                                  \item -s : modify user's login shell
                                  \item -l : modify user's login name
                                  \item -md :modify the users home directory and the old home directory 
                                \end{itemize}
    \bigskip
    \bigskip

    \item\textbf{How to create the duplicate root user?}
    \newline
    Ans.useradd   -o   -u   0   -g   root    <user name>

    \bigskip
    \bigskip

    \item\textbf{How to recover if the user deleted by mistake?}
    \newline
    Ans.\textbf{pwunconv}	(It creates the users according  \textbf{/etc/passwd}  file and deletes the  \textbf{/etc/shadow   file)}

    \bigskip
    \bigskip
     
    \item\textbf{What are the uses of  .bash\_logout,.bash\_profile and .bashrc   files?}
    \newline
      \begin{enumerate}
        Ans.\item\textbf{.bash\_logout} :is a user's logout ending program file. It will execute first whenever the user is logout.
        \item\textbf{.bash_profile} :is user's login startup program file. It will execute first whenever the user is login. It consists 	 the user's environmental variables. 
        \item\textbf{bashrc} :This file is used to create the user's custom commands and to specify the umask values for that user's  only.
       \end{enumerate}

    \bigskip
    \bigskip

    \item\textbf{What is a group?}
    \newline
    Ans.The collection of users is called a group. There are two types of groups.
     \begin{enumerate}
          \item\textbf{Primary group} : It will be created automatically whenever the user is created. User belongs to on group is called a  primary group.
          \item\textbf{Secondary group} :  It will not create automatically. The admin user should be created manually and users belongs to more than one group is called secondary group. A user can be assigned to max. 16 groups. ie., 1 primary group and 15 secondary groups.
     \end{enumerate}

    \bigskip
    \bigskip

    \item\textbf{What is the command to check the user belongs to how many groups?}
    \newline
    Ans. groups     <user name>

     \bigskip
     \bigskip

    \item\textbf{What is the syntax to create the group?}
    \newline
    Ans.\textbf{groupadd}<options><group name>
    The options are,\begin{itemize}
                       \item -f :add the group forcefully
                       \item -g : group id no.
                       \item -o :non-unique  (duplicate group id)
                       \item -p : group password
                       \item -r : system group
                       \item -R : root group  
                    \end{itemize}

    \bigskip
    \bigskip
    
    \item\textbf{What is the syntax to modify the group?}
    \newline
    Ans.The options are,\begin{itemize}
                          \item -g : group id
                          \item-n :new name for existing one, ie., rename the group
                          \item-o : non-unique  (duplicate group id)
                          \item-p : group passwd
                          \item-R :root group
                        \end{itemize}

    \bigskip
    \bigskip

    \item\textbf{What is syntax to delete the group?}  
    \newline
      \begin{itemize}
        \item \textbf{groupdel}    <group name>	(to delete the group without options)
        \item \textbf{groupdel}   <group name>	(to delete the group without options)
       \end{itemize}
       
    \bigskip
    \bigskip
    
    \item\textbf{How to assign the password to the group?}
    \newline
    Ans.\textbf{gpasswd} <group name>	(to assign a password to the group without any options).
        \textbf{gpasswd}    <options><group name>
        The options are,            \begin{itemize}
             	                      \item -a :  add users to the group
				       	              \item -d :  delete the user from the group
					                  \item -r :  remove the group password
					                  \item -R :  restrict to access that group
					                  \item -A : set the list of Administrative users
					                  \item -M :  set the list of group members
                                    \end{itemize}

    \bigskip
    \bigskip

    \item\textbf{How to check the integrity or consistency of the group?}
    \newline
    Ans.grpck	(it will check the integrity or consistency in  \textbf{/etc/gpasswd }  and   /etc/gshadow   files).

    \bigskip
    \bigskip

    \item\textbf{How to restore  /etc/gshadow file if deleted by mistake?}
    \newline
    Ans. grpconv	(it creates the  \textbf{/etc/gshadow}  file  from   \textbf{/etc/group}   file)
    
    \bigskip
    \bigskip

    \item\textbf{How to change the password aging policies?}
    \newline
    Ans.we can change the password policies in 2 ways(I.e configuration file and Chage Command)
        (i)  First  open the  /etc/login.defs   file and modify the current values
        \newline
        \textbf{Example} :vim /etc/login.defs
           \begin{itemize}
             \item min - 0:means the user can change the password to any no. of times.
             \item min  -2: means the user can change the password within 2 days. ie., he can change the password after 2 days.
             \item max - 5:  means the user should change the password before or after 5 days. Otherwise the password will be expired after 5 days.
             \item inactive - 2 :means after password expiry date the grace period another 2 days will be given to change the password.
             \item warning - 7 : means a warning will be given to the user about the password expiry 7 days before expiry date. 
           \end{itemize}
        (ii)  second by executing the   # chage  command.
        \newline
        \textbf{Example} : chage   <options><user name>
        The options are     \begin{itemize}
                               \item -d : last day
                               \item -E : expiry date
                               \item -I : inactive days
                               \item -l :  list all the policies
                               \item -m :  min. days
                               \item-M  : max. days
                               \item-w  : warning days
                            \end{itemize}
         Note :Whenever we \textbf{change} the password aging policy using  chage   command, the information is will be modified in   /etc/shadow   file.

    \bigskip
    \bigskip

    \item\textbf{How add 45 days to the current system date?}
    \newline
    Ans. date   -d    "+  45 days"
   
    \bigskip
    \bigskip

    \item\textbf{Explain the sudo user?}
    \newline
    Ans.Sudoers (nothing but sudo users) allows particular users to run various root user commands without needing a root password. 
    \textbf{/etc/sudoers} is the configuration file for sudoers to configure the normal user as privileged user.
    It is not recommended to open this file using \textbf{vim }   editor because this editor cannot check the syntax by default and whatever we typed in that file that will blindly save in this file.
    So, one editor is specially available for opening this file, i.e.,\textbf{visudo}and all normal users cannot execute this command. Only root user can run this command.
    Once this file is opened nobody can open this file again on another terminal because \textbf{"The file is busy"}message is displayed on the terminal for security reasons.
    
    \bigskip
    \bigskip

    \item\textbf{How to give different  sudo permissions to normal users?}
    \newline
    Ans.Open the \textbf{/etc/sudoers} file by executing    #visudo    command and go to line no. 98 and type as 
    \textbf{<User name>	<Machine>=	<Command>root
           \newline
            ALL=(ALL)	        ALL
            \newline
	         raju		      All=		        ALL}Save and exit this file.
            \newline
    Note :  When we trying to save this file if any syntax errors in this file, those errors are displayed with line no's and \textbf{What you do ?} (will be displayed, here press  'e'  to edit this file and modify those errors or mistakes and save this file.
       \begin{itemize}
          \item su -  raju	(to switch to raju user)
          \item sudo   useradd   <useradd>	(The normal user raju can also add the users to the system)
          \item We can assign sudo permissions to  'n'  no. of users by specifying names separated by commas ( , ) or line by   line.
          \item	Instead of giving all permissions to normal user we can give only some commands.
          \item \textbf{Example} student	ALL=/usr/sbin/useradd, /usr/sbin/usermod
                \newline
                raju	ALL=NOPASSWD:/usr/sbin/useradd, /usr/sbin/usermod
          \item We can also apply to one group or groups as follows.
          \item First create the users, assign one group to those users and also assign the passwords for that users.
          \item Open  \textbf{/etc/sudoers }file by  executing the command \textbf{visudo}and type as follows.
          \item %<group name>	ALL=ALL %oracle	ALL=ALL   or  individual commands separated by commas,
          \item We can also create one command alias and add some commands to that alias and mention that alias to users as follows. 
          \item Cmnd_Alias	NETWORKING=/usr/sbin/route,	  /usr/sbin/ifconfig
          \item <user name>	<machines>=<command alias name>
                \newline
          raju		ALL=
          \item We can also create one user alias and add the users to that alias and assign some commands to that alias as follows.
          \item User_Alias	<user alias name>=<user1>, <user2>, <user3>, 
          \item \textbf{Example}:User_Alias	OURTEAM=raju, shyam, ram, gopal
          \item OURTEAM	ALL=ALL (to give all permissions of sudo)
          \item Defaults  timestamp_timeout=0 (whenever the sudo user executes any command then it will ask password every command)
          \item The above will apply to all users including root also. If we want to make it as only for normal users, then
          \item Defaults  :  <user1>, <user2>, <user3>  timestamp_timeout=0 (the system will ask passwords for user1, user2, user3 to execute sudo commands) 
       \end{itemize}
    
    \bigskip
    \bigskip

    \item\textbf{In which location the sudo  user commands history is logged?}
    \newline
    \begin{itemize}
        \item All the sudo users commands history is logged in  \textbf{/var/log/secure}file to make a record of sudo user commands.
        \item cat   /var/log/secure	(to see the contents of this file)
        \item tailf   /var/log/secure	(to see the updates of this file continuously and press  ctrl + c to quit the tailf)
    \end{itemize}

    \bigskip
    \bigskip

    \item\textbf{How to assign the password to normal user by him whenever first login to the system?}
    \newline
    Ans.Whenever the user is created and that user is trying to login to the system, it will ask the password. If the root user is not assign the password to that user, then that normal user can assign the password by his own using the following commands.
    \begin{itemize}
        \item useradd    <user name>		(to create the user)
        \item passwd  -S  <user name> (to see the status of the password of that user. if root user is not   assigned the password then the password status is  locked)
        \item passwd  -d    <user name>	(then delete the password for that user)
        \item chage    -d   0   <user name>	(it will change the password age policy)
        \item su   -   <user name>		(Try to switch to that user then it will display the following message)
        \item Newpassword :	(type new password for that user)
        \item ⦁	Retype password :(retype the password again)
    \end{itemize}
    \newline
    The other useful commands:
    \begin{itemize}
        \item w :(this command gives the login user information like how many users currently login and full information )
        \item who :(to see users who are currently login and on which terminal they login)
        \item last :(see the list of users who are login and logout since the   \textbf{/var/log/wtmp } file was created)
        \item lastb	:(to see the list of the users who tried as bad logins)
        \item lastreboot:(to see all reboots since the log file was created)
        \item uptime:(to see the information from how long the system is running, how many users login and load   average)
        \item The load average is  from \textbf{1 sec	 :   5 secs   :   15 secs}
        \item df (to see the mounted partitions, their mount points and amount of disk space)
        \item du (to see the disk usage of the each file in bytes)
        \item uname     -r (gives the current kernel version)
        \item last    -x (It shows last shutdown date and time)
        \item last    -x  grep  shutdown	  (only shutdown time shows ie., grep will filter the  'last   -x'   command)
        \item \textbf{grep:}It is used to search a word or sentence in file (ie., inside the file)
        \item \textbf{find :} It is used to search a command or file inside the system)
        \item cat  /etc/shells   or  chsh   -l  	(to see how many shells that are supported by Linux)
        \item /bin/sh : default shell for Unix
        \item /bin/bash: default shell for Linux
        \item /sbin/nologin:users cannot login shell
        \item /bin/tsch:cshell to write  'C++'  language programs
        \item /bin/csh : c shell to write  'C'  language programs
        \item echo   SHELL :(to see the current shell)
        \item chsh    <user name>	(to change the user's  shell)
        \item Changing shell for   <user name> :
        \item New shell  :   <type new shell   for example  /bin/sh   to change the current shell>New shell changed (But it will effect by restarting the server)
        \item date R :(to display the time only)
        \item date  +  x :(to display the date only)
        \item history :(to see the history of the commands)
        \item history -c :(to clear the history)
        \item  history -r :(to recover the history)
        \item \textbf{\_.bash\_history}  is the hidden file to store the history of the user commands. By default history size is 1000.
        \item echo  HISTSIZE :(to check the current history size)
        \item export   HISTSIZE=500	(to change the current history size to 500 temporarily)
        \item export    HISTTIMEFORMAT="  "%D"   "%T"   "(to display the date and time of each command temporarily)
        \item vim  /etc/bashrc (open this file go to last line and type as follows to make history i size date & time 	 formats permanently)
        \item HISTSIZE=1000
        \item HISTTIMEFORMAT='    %D   %T   '(save and exit the file and to update the effects by   #source   /etc/bashrc   command)
        \item ~<user name>:(to go to users home directory)
        \item what is    <command>:(to see the short description of that command)
        \item where is	<command>(to see the location of that command and location of the document of that command)
        \item reset :(to refresh the terminal)
        \item whoami :(to see the current user name)
        \item who  a  mi :(to see the current user with full details like login time and others)
        \item passwd     <user name>	(to change the password of the user)
        \item id (to see the current user name, user id, group name and group id, .... etc.,)
        \item id   <user name>:(to see the specified user name, user id, group name and group id)
        \item su :(to switch to root user without root user home directory)
        \item su :(to switch to root user with root user home directory)
        \item su    <user name	:(to switch to the specified user without his home directory)
        \item su    -    <user name> :(to switch to the specified user with his home directory)
        \item lspci	:(to list all the PCI slots present in the system)
        \item du   -sh   /etc :(to see the size of the   /etc   on the disk in KBs or MBs)
        \item ls    -l  :(to see the long listing of the files and directories)
        \item d  rwx  rwx  rwx   .   2    root    root     6      Dec 17   18:00     File name
        \item d : type of file
        \item rwx : owner permissions
        \item rwx :group permissions
        \item rwx :others permissions
        \item No ACL permissions applied
        \item root :owner of the file
        \item root :group ownership
        \item 6    " size of the file
        \item Dec 7  18:00 : Date and Time of the created or modified
        \item File name :File name of that file
        \item ls    -ld    <directory name>	(to see the long listing of the directories)
        \item stat    <file name/directory name>	(to see the statistics of the file or directory)
    \end{itemize}  
    
    \bigskip
    \bigskip

    \item \textbf{How many types of the files are there?}
    \newline
    Ans.There are 7 types of files.
    \begin{enumerate}
        \item  -:regular file
        \item d :  directory
        \item c : character device file  (Ex.  console file,  open and close terminals, ...etc.,)
        \item b : block device file  (Ex.  device blocks like hard disks, CD/DVD disks)
        \item s :   socket file  (programmers will deal this file)
        \item p :   pipe file      (programmers will deal this file)
        \item l :   linked  file  (nothing but short cut file)
    \end{enumerate}

    \bigskip
    \bigskip

    \item \textbf{What are permission types available in Linux and their numeric representations?}
    \newline
    Ans.There are mainly three types of permissions available in Linux and those are,
    \begin{itemize}
        \item read         -----     r     -----     4	null permission    ------   0
        \item write        -----     r     -----     4
        \item execute   -----     r     -----     4
    \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{What is syntax of chmod command with full options?}
    \newline
    Ans.chmod   <options><file/dir  name>  (to change the owner or permissions of the file/dir)	
    The options are,\begin{itemize}
                         \item c :changes
                         \item	-f :silent  (forcefully)
                         \item	-v  : verbose
                         \item	-R  : recursive (including sub directories and files)
                    \end{itemize} 
    To change the permissions the syntax is,
    chmod  <who>	<what>	<which>		<file name or directory>
    To change the permissions the syntax is,
    chmod  <who>	<what>	<which>		<file name or directory>

    \bigskip
    \bigskip

    \item \textbf{What is the syntax of chown command with full options?}
    \newline
    Ans.chown    <options><file name  or   directory>	(to change the ownership of the file or directory)
    The options are,\begin{itemize}
                       \item c :changes
                       \item-f :silent  (forcefully)
                       \item-v  : verbose
                       \item -h  : no difference
                       \item -R  :recursive  (including sub directories and files)
                       \item -H  :symbolic link to a directory   (command line argument)
                       \item -L  :symbolic link to a directory   (all)
                       \item -p  : do not traverse
                    \end{itemize}
    chown   <username>  :   <group name>	<file name   or   directory name>   (to change owner and group  ownership of the file  or  directory)

    \item \textbf{What is syntax of chgrp command with full options?}
    \newline
    Ans.chgrp    <options><file name   or   directory>	(to change group ownership of the file directory)
    The options are,\begin{itemize}
                       \item c: changes
                       \item -f : silent  (forcefully)
                       \item -v : verbose
                       \item -h : no difference
                       \item -R : recursive  (including sub directories and files)
                       \item -H : symbolic link to a directory
                       \item -L :do not traverse-p : do not traverse
                    \end{itemize}
    
    \bigskip
    \bigskip
    
    \item \textbf{What are the default permissions of a file and directory?}
    \newline
    Ans.\begin{itemize}
            \item The default permissions of a file = 6 6 6
             \item The default permissions of a directory = 7 7 7
        \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{What is umask in linux?}
    \newline
    Ans.
    \newline
    \begin{itemize}
        \item The user file-creation mode mask (umask) is used to determine the file permissions for newly created files or 	directories. It can be used to control the default file or directory permissions for new files. It is a four-digit octal number.  The umask value for normal user is \textbf{0002 }and the umask value for root user is \textbf{0022.}
        \item So, the effected file permissions for normal users  = 6 6 6   -   0 0 2  =   6 6 4.
        \item The effected directory permissions for normal users  = 7 7 7  -  0 0 2  =  7 7 5.
        \item The effected file permissions for root user  = 6 6 6   -   0 2 2   =   6 4 4
        \item The effected directory permissions for root user  =  7 7 7  -  0 2 2   =   7 5 5
        \item umask	<value> 	(to change the umask value temporarily)
        \item vim   /etc/bashrc (open this file and change the umask value to effect the whole system)
        \item source   /etc/bashrc	(to updated the source file)
        \item vim  .bashrc	(open this file in user's home directory and at last type as follows)
        \item umask	<value>	(save and exit the file)
        \item source   .bashrc   or  logout and login again (to the system to effect that umask value)
        \item If the\textbf{/etc/login.defs }   file is corrupted then new users will be added and can be assigned the passwords  but   users cannot login.
        \item  If the   \textbf{/etc/login.defs} file is deleted then new users cannot be added
    \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{How change the permissions using numeric representation?}
    Ans.\begin{enumerate}
          \item The values for  read = 4,  write = 2,  execute = 1  and  null = 0.  The total value = 4 + 2 + 1 = 7
          \item chmod    <no.><no.><no.><file name  or  directory name>
          \textbf{Example : }chmod   7 7 4    file1	(to give read, write and execute to owner and read, write 
          and execute to     group and read permission to others)
          \item chmod   6 6 0	  file2 (to give read and write to owner and read and write to group and null (0)  permission to others)
        \end{enumerate}

    \bigskip
    \bigskip

    \item \textbf{Explain about set uid (suid)?}
    Ans.\begin{itemize}
            \item If we plan to allow all the users to execute the root users command then we go for set uid (suid).
            \item It can be applied for user level and is applicable for files only.
            \item chmod    u+s    <file name>	(to set the suid on that file)
            \item chmod    u-s     <file name>	(to remove the suid from that file)
            \item  ls   -l	(if   'x'  is replaced with   's'  in owner's  level permissions that means suid is applied on that file)
            \item - r w s r w x r w x     <file name>     (here   's'   is called set uid or suid)
            \item \textbf{Example :}   # chmod    u+s    /usr/sbin/init 6	(then any user can restart the system using this command 	   #init 6)
            \item chmod    u+s    /sbin/fdis	(then any user can run the fdisk command)
            \item strings     <command name>	(to read the binary language of the command ie., the string command converts the binary language into human readable language)
            \item strings    mkfs	(to read the mkfs command's binary language into human readable language)
            \item Normally set uid (suid) permission will be given on scripting files only
        \end{itemize}

    \bigskip
    \bigskip

    \item\textbf{Explain about set gid (sgid)?}
    \newline
    Ans.If we plan to allow all the users of one group to get the group ownership permissions then we go for 
    set gid 	   (sgid).	It can be applied for group level and is applicable on directories only.
    \textbf{Example:}  chmod     g+s    <directory name>	(to set the sgid on that directory)
         \newline
			chmod     g-s     <directory name>	(to remove the sgid from that directory)
    
    \bigskip
    \bigskip

    \item\textbf{Explain about sticky bit?}
    \newline
    Ans.It protects the data from other users when all the users having full permissions on one directory.
    \newline
    It can be applied on others level and applicable for directories only.
    Example :  chmod    o+t    <directory name>	(to set the sticky bit permission on that directory)
            \newline
             ls   -ld	<directory name> 	   r w x r w x r w t	<directory name>	(where   't'  is called the sticky bit)


    \bigskip
    \bigskip

    \item \textbf{What are the uses of passwd and shadow files?}
    \newline
    Ans. \textbf {Passwd file}:
           \begin{enumerate}
             \item When we create the user one entry is updated in password and shadow files.
             \item It represents and tell about that user login name , uid, gid, default home directory of the use and default shell. 
             \item So, using this file we can easily get users information.
           \end{enumerate}
        \textbf{Shadow file };
          \begin{enumerate}
             \item This file tells about the login id, user's encrypted password,  password when last changed,  min. days the password valid, max. days valid, warning days, inactive days and expiry days.
             \item If shadow file is missed or deleted we can recover those entries of shadow file using password file.
             \item We can change the users encrypted passwords with the permissions of the higher authorities in case of 	emergency.
          \end{enumerate}  
    
    \bigskip
    \bigskip

    \item \textbf{What is the use of group?}
    \newline
    Ans.\begin{enumerate}
          \item In an organization the whole work is divided into departments for easy maintenance and easy 
          \item For each department is also represented as group and that group having so many users to do different works.
          \item So, if we create one group and assign that group to all the users in that department, then we can easily identify which user belongs to which group.
          \item We can share files, directories and execute some programs to that group and also give permissions to that 	group. So, each user of that group can easily share those directories and also can easily access, execute or even write in those shared files and directories.
        \end{enumerate}
    
    \bigskip
    \bigskip

    \item \textbf{Can we login to the user without password?}
    \newline
    Ans.Yes, we can login.

    \bigskip
    \bigskip

    \item \textbf{How to recover the root password if missed or deleted?}
    \newline
    Ans:\textbf{RHEL - 6 :}
     \begin{enumerate}
        \item Restart the system.
        \item Select  1st  option and press  'e'.
        \item Select 2nd option and press  'e'.
        \item At the end give one blank space and type  1  and press Enter key.
        \item  Then press  'b'  to boot the system in single user mode.
        \item Then prompt appears and type    # passwd root    command.
        \newline
                              New password :  XXXXXX
                              Retype password :  XXXXXX
        \item Exit
        \item Then system starts as usual
     \end{enumerate}
    \textbf{RHEL - 7 :}
      \begin{enumerate}
        \item Restart the system.
        \item Using arrow keys select  1st line and  press  'e'  to edit.
        \item Go to  \textbf{Linux 16 } line press End key  or  \textbf{Ctrl + e } to go to the end of the line and give one space.
        \item Then type as   \textbf{rd.break   console=tty1   selinux=0}
        \item Then press    Ctrl + x   to start the computer in single user mode.
        \item After starting  we get \textbf{ swith_root :/ }  prompt appears and then type as follows.
        \item \textbf{mount   -o   remount, rw    /sysroot }  and press Enter and then type as follows.
        \item \textbf{chroot   /sysroot  }  press Enter
        \item Then   \textbf{sh - 4.2 }  prompt appears and type as 
        \item \textbf{sh - 4.2 passwd root}
               New password :  XXXXXX
               Retype password :  XXXXXX
        \item \textbf{sh - 4.2 exit}
        \item \textbf{switch-root :/exit}
        \item Then the system starts and the desktop appears.
      \end{enumerate}

    \bigskip 
    \bigskip

    \item \textbf{How to restrict the users from login?}
    \newline
    Ans.\begin{enumerate}
          \item  By removing (deleting) the user we can restrict the user from login.
          \item Put the user's hostnames as entries in  \textbf{/etc/hosts.deny }   file (applying TCP wrappers).
          \item \textbf{passwd   -l    <user name> } (by locking his password we can restrict the users).
        \end{enumerate}
    
    \bigskip
    \bigskip

    \item \textbf{How to put never expiry to a user?}
    \newline
    Ans.passwd     -x    -1    <user login name>

    \bigskip
    \bigskip

    \item \textbf{Which one is the default sticky bit directory?}
    \newline
    Ans.	/tmp    is the default sticky bit directory.

    \bigskip
    \bigskip

    \item \textbf{What is the purpose of the profiles?}
    \newline
    Ans.Profile is a file to enter some settings about users working environment. ie., we can set user home directory, 		login shell, path, ...etc., 
    Profiles are two types.
    (a) Global profile
	  (b) Local profile
    \textbf{Global profile}
     \begin{enumerate}
      \item Only root user can set and applicable to all the users.
      \item Only global parameters can entered in this profile.
      \item The location of the global profile is \textbf{/etc/bashrc}
     \end{enumerate}
    \textbf{Local profile}
     \begin{enumerate}
      \item Every user has his/her own profile.
      \item The settings entered in this profile are only for that user.
      \item The location of the profile is\textbf{bash\-profile}(hidden file)  in that particular user's home directory.
     \end{enumerate}

    \bigskip
    \bigskip

    \item \textbf{Can we mount/unmount the  O/S   file system?}
    \newline
    Ans. No, we cannot mount or unmount the   O/S   file system.

    \bigskip
    \bigskip

    \item \textbf{How to find the users who are login and how to kill them?}
    \newline
    Ans. fuser    -cu	:(to see who are login)
    fuser    -ck    <user login name> :(to kill the specified user)

    \bigskip
    \bigskip

    \item \textbf{what is Access Control List (ACL)?}
    \newline
    Ans.Define more access rights nothing but permissions to files and directories. Using Access Control list we assign 	the permissions to some particular users to access the files and directories.
    ACL can cab be applied on ACL enabled partition that means you need to enable ACL while mounting 
    the partition.

    \bigskip
    \bigskip

    \item \textbf{How to implement ACLs?}
    \newline
    Ans.\begin {itemize}
          \item Create a partition and format it with ext4 file system.
          \item  Mount the file system with ACL.
          \item Apply ACL on it.
          \item Create a partition using \textbf{fdisk } command.
          \item Format the above partition with ext4 file system using  \textbf{mkfs.ext4    <partition name> } command.
          \item Create the mount point using  \textbf{mkdir    /<mount point>}  command.
          \item Mount that file system on the mount point using \textbf{mount   -o   acl    <partition name><mount point>	}command.
          \item Mount the partition permanently using \textbf{vim   /etc/fstab }  (open this file and make an entry as below}
          \item \textbf{<partition name><mount point><file system type>     defaults, acl      0    0}
          \item Save and exit this file.
          \item If the partition is already mounted then just add \textbf{acl} after defaults in  \textbf{/etc/fstab}   file and execute 
          \item the below command  \textbf{ mount    -o    remount    <partition name>}
        \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{How to check the ACL permissions?}
    \newline
    Ans.getfacl     <options><file  or  directory name>
    The options are,  \begin{itemize}
                        \item -d:Display the default ACLs.
                        \item -R :Recurses into subdirectories
                      \end{itemize}
    
    \bigskip
    \bigskip

    \item \textbf{How to assign ACL permissions?}
    \newline
    Ans.setfacl     <options><argument> : <username>: <permissions><file  or  directory name>
    The options are,  \begin{itemize}
                        \item -m :  Modifies an ACL.
                        \item -x :  Removes an ACL.
                        \item -b :  Remove all the ACL permissions on that directory.
                        \item -R : Recurses into subdirectories
   The arguments are,   \item  u : user
                        \item g : group
                        \item o : other
                      \end{itemize}    
    
    \bigskip
    \bigskip

    \item \textbf{What is the syntax to assign read and write permissions to particular user, group  and  other?}
    \newline
    Ans.\begin{itemize}
          \item setfacl    -m   u : <user name> : <permissions><file  or  directory>
          \item setfacl    -m   g : <user name> : <permissions><file  or  directory>
          \item setfacl    -m   o : <user name> : <permissions><file  or  directory>
        \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{What is the syntax to assign read and write permissions to particular user, group  and  other  at  a time?}
    \newline
     Ans.setfacl    -m   u : <user name> : <permissions>,  g : <user name> : <permissions>,  o : <user name> : 		<permissions><file  or  directory>
    \newline
    \textbf{Useful  commands :}
    \begin{itemize}
        \item setfacl    -x   u : <user name><file  or  directory name> (to remove the ACL permissions from the user)
        \item setfacl    -x   g : <user name><file  or  directory name>(to remove the ACL permissions from group)
        \item setfacl    -x   o : <user name><file  or  directory name> (to remove the ACL permissions from other)
        \item setfacl    -b    <file  or  directory>	(to remove all the ACL permissions on that file     directory)
    \end{itemize}


    \item\textbf{How will you lock a user, if he enters wrong password  3  times?}
    \newline
     Ans.pam\_tally.so module maintains a count of attempted accesses, can reset count on success, can deny access if 	too many attempts fail. Edit /etc/pam.d/system-auth file, enter:
    \newline
    \begin{itemize}
      \item vi /etc/pam.d/system-auth Modify as follows: auth required pam_tally.so no_magic_root account required pam_tally.so deny=3 no_magic_root lock_time=180
      \item\textbf{deny=3 }: Deny access if tally for this user exceeds 3 times}
      \item\textbf{lock\_time=180 }: Always deny for 180 seconds after failed attempt. There is 
      \item alsounlock_time=n option. It allow access after n seconds after failed attempt. If this option is used the user will be locked out for the specified amount of time after he exceeded his maximum allowed attempts. Otherwise the account is locked until the lock is removed by a manual intervention of the system administrator.
      \item \textbf{magic\_root }: If the module is invoked by a user with uid=0 the counter is not incremented. The sys-admin should use this for user launched services, like su, otherwise this argument should be omitted.
      \item no_magic\_root : Avoid root account locking, if the module is invoked by a user with uid=0.Save and close the file.
    \end{itemize}

    \bigskip
    \bigskip
    
    \item \textbf{How to see the no. of failed logins of the users?}
    \newline
     Ans.\begin{itemize}
          \item faillog    -u    <user name> :(to see the specified users failed login attempts)
          \item faillog    -a 	: (to see failed login attempts of all users)
          \item faillog    -M  <Max. no>    -u    <user name>	:(to set Max. login failed attempts to that user)
          \item faillog    -M  5    -u    raju	:(to set Max. login failed attempts to 5 for user raju)
        \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{What is disk quotas and how to enable them?}
    \newline
    Ans.By configuring the disk quotas we can restrict the user to use unlimited space on the file system and 
        also to 	restrict the unlimited files in the file system. We can configure the disk quotas in ways. They are,
      \begin{itemize}
        \item user quotas
        \item 	group quotas
      \end{itemize}
     \textbf{Steps to enable :}
     First check whether the quota package is installed  or  not  by \textbf{rpm    -qa  |grep   quota    command. If quota}	package is not Installed then install the  quota package by \textbf{yum  install  quota*   -y }   command.
      \begin{itemize}
        \item quotaon	:(to enable the quota)
        \item  quotaoff	:(to disable the quota)
        \item  edquota	:(to edit  or  modify the quota)
        \item repquota	:(to display  or  report the present quota)
        \item quotacheck :(to create a quota database)
      \end{itemize}
    quotas  cab be applied on file systems only.

    \bigskip
    \bigskip

    \item \textbf{How to enable the user quota on a file system?}
    \newline
    Ans.\begin{itemize}
           \item Open the  /etc/fstab   file by  \textbf{ vim  /etc/fstab }command  and  goto the mount point entry line and type as, /dev/sdb1	/mnt/prod	ext4	defaults,  usrquota 	0	0	(save and exit this file)
           \item Update the quota  on mount point by  # \textbf{mount   -o   remount, usrquota    <mount point> } ii	command.
           \item Create the user quota database by  # quotacheck     -cu    <mount point>    command  (where   -c    means  	created the quota database   and   -u   means  user quota).
           \item Check whether the quota is applied  or  not  by   # mount    command.
           \item Enable the quota  by   # quotaon     <mount point>    command.
	         \item Apply the user quota  for a user  by   \textbf{edquota     -u    <user name><mount point>}    
           \item blocks: No. of blocks used  (already)
		       \item soft : Warning limit
		       \item hard : Maximum limit
		       \item 0     : Unlimited usage
		       \item inodes : No. of files created  (already)
        \end{itemize}
        If  soft=10   and   hard=15  means after crossing the soft limit a warning message  will be 
        displayed  and  if 	 hard limit is also crosses then it won't  allow to create the files for that user.
        (save and exit the above quota editor)

    \item \textbf{How to enable the quota on block level?}
    \newline
    Ans.Apply the user quota for a user by  # edquota   -eu    <user name><mount point>    command.
    File system	blocks		soft		hard		inodes      	soft      
    \newline
    hard	/dev/sdb1	     0		5000	              10000		     0	
    0	   0	(save and exit the quota editor)
      \begin{itemize}
         \item soft=5000 : means if it reaches  upto  5MB, there is no warnings. If  it exceeds  ie., from 5MB  -  10MB there will be warnings messages displayed, but the files 
         \item hard=10000 : If it reached to 10MB, then it will not allow to create the files. The grace period by default 	is 7 days. So, we can change the grace period by   #edquota    -t    command,  here we can      change the default  7 days grace period  to  our required days of grace period.grace period  means, if the user not created any files within the grace period days the soft limit becomes as  hard limit. ie., soft and hard limits are equal.
      \end{itemize}
      \newline
      edquota    -p    <user name 1><user name 2>:to apply  user name 1 quotas to user name 2, ie., no 							           need to edit the quota editor for user name 2)
    
    \bigskip
    \bigskip

    \item \textbf{How to enable the group quota?}
    \newline
    Ans.\begin{enumerate}
          \item Open the \textbf{/etc/fstab   file by  # vim  /etc/fstab  } command  and  goto the mount point entry line and type as,/dev/sdb1	/mnt/prod	ext4	defaults,  grpquota	0	0
            save and exit this file
          \item Update the quota on mount point by  \textbf{ mount  -o  remount, usrquota, grpquota  <mount point>}command
          \item Create the user quota database by  \textbf{quotacheck    -cug    <mount point>    command  }
            where   -c   means  			    created the quota database,   -u   means  user quota  and -g means  group quota ).
          \item Check whether the quota is applied  or  not  by   \textbf{mount }   command.
          \item Enable the quota  by   # quotaon  \textbf{ <mount point>   } command.
          \item  Apply the user quota  for a user  by   \textbf{edquota     -g    <group  name><mount point>    command.}
          \item File system	blocks		soft		hard		inodes      
          \item /dev/sdb1	     0		   0		    0		     0		    0		    0
        \end{{enumerate}
        \begin{itemize}
          \item blocks: No. of blocks used  (already)
          \item soft  :  Warning limit
          \item hard  :   Maximum limit
          \item 0      :  Unlimited usage
          \item inodes :  No. of files created  (already)
        \end{itemize}
      Here we can specify the block level quota  or  file level  quotas.
		   group quota can be applicable to all the users of that specified  group.
		  (save and exit the above quota editor)

    \bigskip
    \bigskip

    \item \textbf{How to change the password for multiple  users  at a time}
    \newline
    Ans.chpasswd :(to change multiple user's  passwords)
        \begin{itemize}
           \item <user name 1> : <password>
           \item  <user name 2> : <password>
           \item  <user name 3> : <password>
           \item <user name 4> : <password>
           \item <user name 5> : <password>
           \item (Ctrl + d    ----->   to save and exit)
	      \end{itemize}
        Then  the above 5 user's passwords will be changed at a time. But here the passwords will not be encrypted while typing passwords. So, anybody can see the passwords.  ie., there is no security.
\end{enumerate}   
    \bigskip 
    \bigskip
    \bigskip 

\textbf{Managing Partitions and File Systems}
   
\bigskip

\begin{enumerate}
   \item \textbf{What is partition?}
   \newline
    Ans.A partition is a contiguous set of blocks on a drive that are treated as independent disk. 
   
   \bigskip
   \bigskip
  
   \item \textbf{What is partitioning?}
   \newline
   Ans.Partitioning means to divide a single hard drive into many logical drives.

   \bigskip
   \bigskip

   \item \textbf{Why we have multiple partitions?}
   \newline
   Ans.\begin{itemize}
        \item Encapsulate our data.
        \item Since file system corruption is limited to that partition only.
        \item So we can save our data from accidents. 
        \item We can increase the disk space efficiency
        \item Depending on our usage we can format the partition with different block sizes.
        \item So we can reduce the wastage of the disk.
        \item We can limit the data growth by assigning the disk quotas
      \end{itemize}

  \bigskip
  \bigskip

  \item \textbf{What is the structure of the disk partition?}
  \newline
  Ans.The first sector of the O/S disk contains the MBR (Master Boot Record). The MBR is divided into 3 parts and it's size is 512 bytes. The first part is IPL (Initial Program Loader) and it contains the Secondary Boot Loader. So, IPL  is responsible for booting the O/S and it's size is 446 bytes The second part is PTI (Partition Table 
  Information). It contains the number of partitions on the disk, sizes of the partitions and type of the partitions

  \bigskip
  \bigskip

  \item \textbf{Explain the disk partition criteria?}
  \newline
  Ans.Every disk can have max. 4 partitions. The 4 partitions are 3 Primary partitions and 1 Extended partition.
  The MBR and O/S will install in Primary partition only. The Extended partition is a special partition and can be further divided into multiple logical partitions.
  
  \bigskip
  \bigskip

  \item \textbf{How to identify the disks?}
  \newline
  Ans.\begin{itemize}
         \item In Linux different types of disks will be identified by different naming conventions.
         \item IDE) drives will be shown as /dev/hda, /dev/hdb, /dev/hdc, ...etc.,  and the partitions are /dev/hda1,  /dev/hda2, /dev/hda3, ...etc.
         \item iSCSI/SCSI  and SATA drives will be shown as /dev/sda, /dev/sdb, /dev/sdc, ...etc.,  and the partitions are /dev/sda1, /dev/sda2, /dev/sda3, ...etc.,
         \item Virtual drives will be shown as /dev/vda, /dev/vdb, /dev/vdc, ...etc.,  and the partitions are /dev/vda1, /dev/vda2, /dev/vda3, ...etc.,
         \item IDE :Integrated Drive Electronics.
         \item iSCSI:Internet Small  Scale System Interface.
         \item SCSI : Small Scale System Interface.
      \end{itemize}
  
  \bigskip
  \bigskip

  \item \textbf{What is file system?}
  \newline
  Ans.It is a method of storing the data in an organized fashion on the disk. Every partition on the disk except MBR and 	Extended partition should be assigned with some file system in order to make them to store the data. File system is applied on the partition by formatting it with a particular type of file system.
  
  \bigskip
  \bigskip

  \item \textbf{What are the different types of file systems supported in Linux?}
  \newline
  Ans.\begin{itemize}
        \item The Linux supported file systems are ext2, ext3, ext4, xfs, vfat, cdfs, hdfs, iso9660 ...etc.,
        \item  The ext2, ext3, ext4 file systems are widely used in RHEL-6 and xfs file system is introduced on RHEL-7. 
        \item The vfat file system is used to maintain a common storage between Linux and Windows O/S.
        \item The cdfs file system is used to mount the CD-ROMs and the hdfs file system is used to mount DVDs.
        \item The iso9660 file system is used to read CD/DVD.iso image format files in Linux O/S.
  \end{itemize}

  \bigskip
  \bigskip
  
  \item \textbf{How to create different types of partitions?}
  \newline
  Ans. fdisk -l fdisk /dev/sdc
	   Command (m for help) : n   (type n for new partition)
	  (p - primary) or e - extended) : p (type p for primary partition or type e for extended partition)
    \begin{itemize}
      \item First cylinder :  (press Enter for default first cylinder)
	    \item Last cylinder :  + <size in KB/MB/GB/TB>
	  \end{itemize}
	  Command (m for help) : t   (type   t   to change the partition id)
    for example:    8e for Linux LVM,   82  for Linux Swap   and  83  for  Linux normal partition)
		Command (m for help) : w        (type   w   tosave the changes into the disk)
	  partprobe /partx  -a/kpartx   /dev/sdc1       (to update the partitioning information in partition table)
  
  \bigskip
  \bigskip

  \item \textbf{How to make a file system in Linux?}
  \newline
  Ans. mkfs.ext2/ext3/ext4/xfs/vfat	<device name> ( for example/dev/sdc1)

  \bigskip
  \bigskip

  \item \textbf{How to mount the file systems temporarily or permanently?}
  \newline
  Ans.mkdir /mnt/oracle	
      mount /dev/sdc1  /mnt/oracle   (temporary mount)
      vim /etc/fstab
          /dev/sdc1		/mnt/oracle 	       xfs		defaults	0	0
	Esc+:+wq!
	# mount   -a  (permanent mount)

  \bigskip
  \bigskip

  \item \textbf{How to delete the partition?}
  \newline
  Ans. fdisk  /dev/sdc
  Command (m for help) :d          (type   d   for delete the partition)
  Partition number :  (specify the partition number)
  Command (m for help) : w      (type   w   to write the changes into disk)
  partprobe/partx  -a/kpartx   /dev/sdc1(to update the partition table without restarting the system)

  \bigskip
  \bigskip

  \item \textbf{What is mounting and in how many types can we mount the partitions?}
  \newline
  Ans. Attaching a parititon to a directory under root is known as mounting.There two types of mountings in Linux/Unix.
   \begin{itemize}
     \item Temporary Mounting:In a temporary mounting first we create a directory and mount the partition on that directory. But this type mounting will last only till the system is up and once it is rebooted the mounting will be lost.
      Example:# mount   <options><device name><directory name (mount point)>
     \item Permanent Mounting :In this also first we create the directory and open the /etc/fstab file and make an entry as below,
    <device name><mount point><file system type><mount options><take a backup or not><fsck value>
   \end{itemize} 
    Whenever the system  reboots mount the partitions according to entries in /etc/fstab file. So, these type of mountings are permanently even after the system is rebooted.
    # mount   -a          to mount the partitions without reboot)

  \bigskip
  \bigskip

  \item \textbf{Which files are related to mounting in Linux?}
  \newline
  Ans.\begin{itemize}
         \item \textbf{/etc/mtab: }is a file which stores the information of all the currently mounted file systems and this file is    dynamic  and keep on changing.
         \item \textbf{/etc/fstab }is keeping information about the permanent mount points. If we want to make our mount point  permanent then make an entry about the mount point in this file.
      \end{itemize}
      /etc/fstab  entries are:
      1		           2	                  	3	            4		     5		 6
      device name     mount point       F/S type	mount options	Dump                    FSCK 


  \bigskip
  \bigskip

  \item \textbf{The partitions are not mounting even though there are entries in /etc/fstab. How to solve this problem?}
  \newline
  Ans. First check any wrong entries are there in /etc/fstab file. If all are ok then unmount all the partitions by executing the below command,
    \_umount    -a Then mount again mount all the partitions by executing the below command,
    \_mount   -a

  \bigskip
  \bigskip

  \item \textbf{When trying to unmounting it is not unmounting, how to troubleshoot this one?}
  \newline
  Ans.Some times directory reflects error while unmounting because,(i) you are in the same directory and trying to unmount it, check with # pwdcommand.
	(ii) some users are present or accessing the same directory and using the contents in it, check this with 
     \begin{itemize}
       \item fuser -cu  <device name>       (to check the users who are accessing that partition)
       \item lsof  <device name>     (to check the files which are open in that mount point)
       \item fuser   -ck   <opened file name with path>      (to kill that opened files)
     \end{itemize}
     Now we can unmount that partition using   # umount     <mount point>
  
  \bigskip
  \bigskip


  \item \textbf{How to see the usage information of mounted partitions?}
  \newline
  Ans.df   -hT       (to see device name, file system type, size, used, available size, use% and mount point)
  
  \bigskip
  \bigskip

  \item \textbf{How to see the size of the file or directory?}
  \newline
  Ans.\begin{itemize}
         \item du   -h   <filename or directory  name> :(to see the size of the in that directory)
         \item du   -h  :(to see all the file sizes which are located in the present working directory)
         \item du  .| sort  -nr | head  -n10  :(to see the biggest files from current location)
         \item du  -s * | sort  -nr | head  -n10    : (to see the biggest directories from that partition)
         \item ncdu   :(to list biggest files and directories, we have to install the ncdu package  before executing this) 
      \end{itemize}
  
  \bigskip
  \bigskip

  \item \textbf{How to assign a label to the partition?}
  \newline
  Ans.e2label   <device name or partition name><label name>      (to assign the label to that partition)
  Example :    # e2label  /dev/sdb1  oradisk      (to assign oradisk label to /dev/sdb1 partition)
	# mount   -l       (to list all the mounted partitions along with their labels)
  
  \bigskip
  \bigskip

  \item \textbf{How to mount a partition temporarily or permanently using label?}
  \newline
  Ans.mount   LABEL=<label name><mount point> ex :  # mount   LABEL=oradisk     /mnt/oracle    (to mount the oradisk label on /mnt/oracle directory)
    # vim  /etc/fstab
    LABEL=oradisk	/mnt/oracle	ext4	defaults	0	0
    Esc+:+wq!    (to save and exit the file)
    # mount    -a       (to mount the partitions)
    # mount	(to verify whether it is mounted or not)

  \bigskip
  \bigskip

  \item \textbf{How mount the partition permanently using block id (UUID)?}
  \newline
  Ans. blkid   <partition name or disk name>       (to see the UUID or block id of that partition)
	 Example :  #blkid   /dev/sdb2       (to see the UUID or block id of the /dev/sdb2 partition)
	 Copy that UUID with mouse and paste it in /etc/fstab file and make an entry about that.
	 Example:  # vim /etc/fstab
	 UUID="{.......................}"  	/mnt/oracle	ext4	defaults	0	0
	 Esc+:+wq!      (to save and exit)

  \bigskip
  \bigskip

  \item \textbf{What is the basic rule for swap size?}
  \newline
  Ans.\begin{itemize}
         \item If the size of the RAM is less than or equal to 2GB, then the size of the swap = 2 X RAM size.
         \item If the size of the RAM is more than 2GB, then the size of the swap = 2GB + RAM size
      \end{itemize}
   
  \bigskip
  \bigskip

  \item \textbf{How to create a swap partition and mount it permanently?}
  \newline
  Ans.\begin{itemize}
        \item free   -m  :(to see the present swap size)
        \item swapon  -s   :(to see the swap usage)
        \item fdisk   <disk name>	(to make a partition)
        \item Example:  # fdisk   /dev/sdb
        \item Command (m for help) :  n    (to create a new partition)
        \item First cylinder :  (press Enter to take as default value)
        \item Last cylinder :  +2048M   (to create 2GB partition)
        \item Command (m for help) :   t     (to change the partition id)
        \item Enter the partition No.:  2      (to change the /dev/sdb2 partition id)
        \item Enter the id :  82    (to change the partition id Linux to Linux Swap)
        \item Command (m for help) :  w    (to save the changes into the disk)
        \item partprobe  /dev/sdb        (to update the partition table information)
        \item mkswap  <device or partition name>     (to  format the partition with swap file system)
        \item Example :  # mkswap   /dev/sdb2        (to format the /dev/sdb2 partition with swap file system)
        \item swapon    <device or partition name>     (to activate the swap space)
        \item Example :  # swapon   /dev/sdb2       (to activate /dev/sdb2  swap space)
        \item free   -m       (to see the swap size)
        \item vim /etc/fstab	   (to make an entry to permanent mount the swap partition)
        \item /dev/sdb2		swap	swap	defaults	0	0
        \item Esc+:+wq!     (to save and exit)
  \end{itemize}

  \bigskip
  \bigskip

  \item \textbf{What are the attributes of the file system?}
  \newline
  Ans.\begin{itemize}
          \item Inode number
          \item File name
          \item data block 
      \end{itemize}

  \bigskip
  \bigskip

  \item \textbf{What is inode number and what is the use of it?}
  \newline
  Ans.Inode numbers are the objects the Linux O/S uses to record the information about the file.Generally inode number contains two parts.
    \begin{itemize}
      \item Inode first part contains information about the file, owner, its size and its permissions.
      \item Inode second part contains pointer to data blocks associated with the file content.
    \end{itemize}
    \newline
    That's why using the inode number we can get the file information quickly.

  \bigskip
  \bigskip
  
  \item \textbf{How to check the integrity of a file system or consistency of the file system?}
  \newline
   Ans.\textbf{# fsck   <device or partition name>} command we can check the integrity of the file system.
   But before running the fsck command first unmount that partition and then run fsck command.
 
  \bigskip
  \bigskip

  \item \textbf{What is fsck check or what are the phases of the fsck?}
  \newline
  Ans.\begin{itemize}
        \item First it checks blocks and sizes of the file system
        \item  Second it checks file system path names
        \item Third it checks file system connectivity
        \item Fourth it checks file system reference counts (nothing but inode numbers)
        \item  Finally it checks file system occupied cylindrical groups
      \end{itemize}

  \bigskip
  \bigskip

  \item \textbf{Why the file system should be unmount before running the fsck command?}
  \newline
  Ans.If we run \textbf{fsck }on mounted file systems, it leaves the file systems in unusable state and also deletes the data. 	So, before running the fsck command the file system should be unmounted.
  

  \bigskip
  \bigskip

  \item \textbf{Which type of file system problems you face?}
  \newline
  Ans.\begin{itemize}
         \item File system full
         \item File system corrupted
      \end{itemize} 

  \bigskip
  \bigskip
    
  \item \textbf{How to extend the root file system which is not on LVM?}
  \newline
   Ans.By using \textbf{gparted }	command we can extend the root partition, otherwise we cannot extend the file systems 	which is not on LVM.

  \bigskip
  \bigskip

  \item \textbf{How to unmount a file system forcefully?}  
  \newline
  Ans.umount    -f    <mount point>
  \newline
	    fuser    -ck    <mount point>

  \bigskip
  \bigskip

  \item \textbf{How to know the file system type?}
  \newline
   Ans.df   -hT       (command gives the file system type information)

   \bigskip
   \bigskip

  \item \textbf{How to know which file system occupy more space and top 10 file systems?}
  \newline
  Ans. df   -h   <device or partition name>  | sort   -r  |  head    -10
  
  \bigskip
  \bigskip

  \item \textbf{What is the command to know the mounted file systems?}
  \newline
  Ans. mount    or  # cat  /etc/mtab

  \bigskip
  \bigskip

  \item \textbf{How to know whether the file system is corrupted or not?}
  \newline
  Ans. First unmount the file systems and then run \textbf{fsck }command on that file system.

  \bigskip
  \bigskip

  \item \textbf{How to recover if a file system is corrupted or crashed?}
  \newline
  Ans. If the normal or not related to O/S file system is corrupted first unmount that file system and run fsck command on that file system and if the O/S related file system is corrupted then boot the system with CDROM in single 	user mode and run the fsck command.
  If the normal or not related to O/S file system is crashed then restore it from the recent backup and if the O/S 	related file system is crashed then boot the system with CDROM in single user mode and restore it from the recent backup

  \bigskip
  \bigskip

  \item \textbf{How to create a file with particular size?}
  \newline
   Ans.dd  if=/dev/zero of=/orafile   bs=1MB  count=500 (to create 500MB size  /orafile with 4KB blocksize)

   \bigskip
   \bigskip

  \item \textbf{How to find how many disk are attached to the system?}
  \newline
  Ans. fdisk    -l     (to see how many disk are attached to the system)

  \bigskip
  \bigskip

  \item \textbf{What is journaling?}
  \newline
  Ans. It is a dedicated area in the file system where all the changes are tracked when the system crashed. So the 	possibility of the file system corruption or crashes is less because of this journaling  feature.

  \bigskip
  \bigskip
  
  \item \textbf{How to repair the Superblock of the file system?}
  \newline
  Ans.Whenever we want to store the data into the hard disk, if the input/output error occurs then the Superblock of 	the file system may be erased or corrupted. So, we have to restore or repair that Superblock.
	 # umount    <file system mount point>	(to unmount the file system)
	 # dumpe2fs   </dev/vgname/lvname>  | grep  superblock    (to list the superblocks first primary superblock and  then secondary superblock and so on)
	 # e2fsck   -b   <copy and paste the secondary super block from the above list></dev/vgname/lvname>
			(to restore the damaged superblock)
	 # mount   -a 	(to mount the file system)

  \bigskip
  \bigskip

  \item \textbf{How to create the file systems with the user specified superblock reserve space?}
  \newline
  Ans. # mkfs.ext4   -m  <no.><partition name>	(to format the partition with <no.>% of reserve space to superblock)
   
  \bigskip
  \bigskip

  \item \textbf{How to modify the superblock reserve space?}
  \newline
  Ans. # tune2fs   -m  <no.><partition name>	(to modify the  superblock reserve space to  <no.>%) 

  \bigskip
  \bigskip

  \item \textbf{How to modify the superblock reserve space?}
  \newline
  Ans. tune2fs   -m  <no.><partition name>	(to modify the  superblock reserve space to  <no.>%) 
  \newline
   \textbf{Important Commands :}
     \begin{itemize}
       \item fsck   <partition name>	:(to check the consistency of the file system)
       \item e2fsck  <partition name> :(to check the consistency of the file system in interactive mode)
       \item e2fsck   -p   <partition name>:(to check the consistency of the file system without interact mode)
       \item mke2fs   -n  <partition name>	:(to see the superblock information)
       \item mke2fs   -t  <file system type><partition name> :(to format the partition in the specified filesys type)
       \item mke2fs    <partition name>:(to format the partition in default ext2 file system type)
       \item blockdev   --getbs   /dev/sdb1	(to check the block size of the /dev/sdb1 file system)fsck <device or partition name>	(to check and repair the file system) 
     \end{itemize}
     Note: Before running this command first unmount that partition then run fsck command.
    \begin{itemize}
      \item # umount   -a :(to unmount all the file systems except ( / ) root file system)
      \item mount:to mount all the file systems which are having entries in /etc/fstab file)
      \item # fsck   -A 	:	(to run fsck on all file systems)
      \item # fsck   -AR   -y 	:	(to run fsck without asking any questions)
      \item# fsck   -AR   -t   ext3   -y	:	(to run fsck on all ext3 file systems)
      \item# fsck   -n   /dev/sdb1	:(to see the /dev/sdb1 file system report without running fsck)
      \item # tune2fs   -l   /dev/sdb1	:	(to check whether the journaling is there or not)
      \item# tune2fs   -j   /dev/sdb1	:	(to convert ext2 file system to ext3 file system)
      \item# tune2fs   -l   /dev/sdb1	:	(to check whether the journaling is added or not)
      \item # tune2fs   -O  ^has_journal   /dev/sdb1	:(to convert ext3 file system to ext2 file system)
      \item # tune2fs   -O  dir_index, has_journal, unit_bg   /dev/sdb1	:(to convert ext2 file system to ext4 file system)
      \item# tune2fs   -O  extents, dir_index, unit_bg   /dev/sdb1 	: (to convert ext3 file system to ext4 file system)
      \item# mount   -o  remount, rw    /dev/sdb1	:(to mount the partition with read and write permissions)
      \item# mount   -o  remount, ro    /dev/sdb1:	(to mount the partition with read only permissions)
      \item # mount   < directory name>  :		 (to check whether this directory is mount/ normal directory)
      \item dump2fs   <device or partition name>	:(to check the metadata of the partition and repair the metadata)
      \item # fdisk   -l 	:(to list total hard disks attached to system and their partitions)
      \item # fuser   -cu   <device or partition name> :(to see the users who are accessing that file system)
      \item # fuser   -cK   <device or partition name>  :(to kill the users processes who accessing the file systems)
    \end{itemize}
    \textbf{Note:}Even though we kill those users processes sometimes we cannot unmount those partitions, so if this situation arises then first see the process id's of the user opened files by
    \textbf{lsof  <mount point>   # kill   -9   <process id>} killthose processesforcefully   
    # journalctl	(It tracks all the log files between two different timings and by default saved in \textbf{ /run/log  )}
    \textbf{/run/log } is mounted on \textbf{ tmpfs} file system. ie., if system is rebooted, the whole information in that location will be deleted or  erased.
    We can change /run/log   is mounted on  tmpfs  file system. ie., if system is rebooted, the whole information in that location will   be deleted   or   erased.
      \begin{itemize}
        \item # mkdir    -p    /var/log/journal	:(to make a directory in   /var/log location
        \item chown    root : systemd-journal      /var/log/journal       (to change the group ownership of   /var/log/journal
        \item chmod    g+s    /var/log/journal:(to set the  sgid  on   /var/log/journal)
        \item killall    -URS1    systemd-journald:(It is necessary to kill old   /run/log   process   and the location of journal messages is changed to  /var/log/journal)
        \item # journalctl    -n    5		:	(to display last five lines of all the log files)
        \item # journalctl    -p   err		:	(to display all the error messages)
        \item journalctl    -f 	:(to watch journalctl messages continuously)
        \item journalctl     --since<today>   or   <yesterday>  :  (to see all the journalctl messages since today   or  yesterday) 
        \item journalctl     --since   "date"    --until    "date"  : (to see the journal messages between the specified two dates) 
        \item journalctl     -pid=1	:(to see the  pid=1  process name)
        \item # auditctl	:(to see the audit report).
      \end{itemize}
\end{enumerate}    


\bigskip
\bigskip

\textbf{Logical Volume Management and RAID Levels}

\bigskip
\bigskip

\begin{enumerate}
  \item \textbf{What is LVM and why we go for LVM?}
  \newline
   Ans. \textbf{Lvm}means Logical Volume Management. The combination of 2 or more physical disk in order to make a big  	logical disk is called Logical Volume.  
        \newline
        If normal Linux partition is full and an application requires some more disk space, then normal partition cannot 	be extended for that application requirement. For this first we have to take a backup of that normal partition, 	delete that partition and again create that partition with more disk space, format and mount that partition and 	finally restore the application from the backup. This process requires down time
        So, to overcome this problem  LVM  concept is coming into the picture. Using this LVM we can extend or reduce 	the file systems as per requirement without loss of any data.

  \bigskip
  \bigskip

  \item \textbf{What are the components of the LVM?}
  \newline
   Ans.\begin{itemize}
          \item Physical Volume (PV)
          \item Physical Extent (PE)
          \item Volume Group (VG)
          \item Logical Volume (LV)
          \item Logical Extent (LE)
       \end{itemize}
      \begin{enumerate}
        \item \textbf{Physical Volume (PV) }:It is the standard partition that we add to the LVM. Normally a physical volume is a standard primary or logical partition with the partition code as \textbf{8e.}
        \item \textbf{Physical Extent (PE) }:It is chunk of disk space. Every physical volume is divided into a number of equal sized PEs.
        \item \textbf{Volume Group (VG)} :It is composed of a group of physical volumes and logical volumes. It is the organizational group of LVM.
        \item \textbf{Logical Volume (LV)}: It is composed of a group of LEs. We can format (make a file system) and mount any file system on the logical volume. The size of these logical volumes can easily be increased or decreased as per the requirement.
        \item \textbf{Logical Extent (LE)}:It is also a chunk of disk space. Every logical extent is mapped to a specific physical extent.
      \end{enumerate}

  \bigskip
  \bigskip

  \item \textbf{How to create the LVM, make a file system and mount that permanently?}
  \newline
   Ans. \begin{itemize}
            \item Take two physical disks for example  \textbf{/dev/sdb }  and    /dev/sdc. if there is no second disk then make the 			required partitions using  # fdisk command and change the partition code as 8e.
            \item Convert the Physical disk into physical volumes by,\textbf{pvcreate   /dev/sdb    /dev/sdc}
            \item Then create the volume group by combining physical volumes by,
              \textbf{vgcreate  <volume group name><physical volume names>   or}
              \textbf{# vgcreate   -s  <PE size in MBs><volume group name><physical volume names>}
            \item Then create the logical volume on the above created volume group by,
               \textbf{lvcreate   -L  +<size in MBs>   -n  <logical volume name><Volume group name>  or}
               \textbf{# lvcreate   -l   <no. of PEs>    -n   <logical volume name><volume group name>}
            \item  Make a file system on the above created logical volume by,  
              \textbf{mkfs.ext2/ext3/ext4/xfs    /dev/<volume group name>/<logical volume name>}
              Create a mount point to mount the above created LVM file system by,
               \textbf{mkdir   /mnt/<directory name>}
            \item Mount the LVM on the above created mount point temporarily by,
            \textbf{mount   /dev/<volume group name>/<logical volume name><mount point>or}
            Mount the LVM on mount point permanently by,
             \textbf{vim  /etc/fstab
	          /dev/<VG name>/<LV name>	/mnt/<directory>	<file system type>	defaults	0	0}
            Esc+:+wq!
            \item \textbf{mount   -a}
            \item \textbf {df   -hT } :  (to see the mounted partitions with file system types)
        \end{itemize}
    
    \bigskip
    \bigskip

    \item \textbf{How to see the details of the Physical Volumes?}
    \newline
    Ans.\begin{itemize}
           \item pvs :(displays all physical volumes with less details)
           \item  pvdisplay :	(displays  all physical volumes with more details)
           \item pvdisplay <physical volume name> :	(displays the details of the specified physical volume)
           \item pvscan	:(to scan all the physical volumes)
           \item #pvscan    <PV name>	:(to scan the specified physical volume)
        \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{How to see the details of the Volume Groups?}
    \newline
    Ans.\begin{itemize}
          \item vgs	:(displays all volume groups with less details)
          \item# vgdisplay :(displays all volume groups with more details)
          \item # vgdisplay   <VG name>	:(displays the specified volume group with more details)
          \item# vgscan 	:(to scan all the volume groups)
          \item# vgscan    <VG name>:(to scan the specified volume group)
        \end{itemize}

    \bigskip
    \bigskip
    
    \item \textbf{How to see the details of the Logical Volumes?}
    \newline
    Ans.\begin{itemize}
           \item lvs :(displays all logical volumes with less details)
           \item # lvdisplay :(displays all logical volumes with more details)
           \item # lvdisplay   <LV name>:(displays the specified logical volume details)
           \item # lvscan	:(to scan all the logical volumes)
           \item # lvscan    <LV name>	: (to scan the specified logical volume)	
        \end{itemize}
    
    \bigskip
    \bigskip

    \item \textbf{How to extend the Volume Group?}
    \newline
    Ans. Extending the volume group is actually adding a new physical volume to the volume group.
    To extend the volume group we need to create a new partition using \textbf{# fdisk }command and make sure that it's partition id should be \textbf{8e,} save the changes and update the partition table by \textbf{# partprobe}
    \newline 
    Create a physical volume on the newly created partition using \textbf{ # pvcreate} command.
    Add the partition to the volume group using \textbf{# vgextend }command 
    Example :  # fdisk   /dev/sdb
            \begin{itemize}
              \item Command (m for help) : n
              \item First cylinder : press Enter for default one
              \item Last cylinder : +500M  :(create 500MB partition)
              \item  Command (m for help) : t   	(to change the partition id)
              \item Select the partition : type the partition number
              \item Specify the Hexa code : 8e
              \item Command (m for help) : w   	(to save the changes)
            \end{itemize}
            partprobe   /dev/sdb1
	          # pvcreate   /dev/sdb1
	          # vgextend   <VG name>   /dev/sdb1
	          # vgdisplay   <VG name>	:(to check the size of the volume group)

    \bigskip
    \bigskip
    
    \item \textbf{How to extend the logical volume and update it's file system?}
    \newline
    Ans. Sometimes the file system size may be full, so we need to increase the size of the logical volume to continue adding the data in it.
    The size of the logical volume can be increased online, no downtime required.
    Check current size of the logical volume by \textbf{# lvdisplay  <LV name>}and the size of the file system by # df -hT  command.
    Increase the size of the logical volume by \textbf{# lvextend or # lvresize}commands.
    Then finally update the file system by \textbf{# resize2fs or # xfs_growfs} commands.
    Example :   # df   -hT
			# lvextend    -L   +<size in MB></dev/vgname/lvname>    or
			# lvresize   -L   +<size in MB></dev/vgname/lvname>
			# resize2fs    </dev/vgname/lvname>
			# lvdisplay   </dev/vgname/lvname>:(to check the size of the logical volume)
			# df    -hT	:(to check the size of the file system)
    
    \bigskip
    \bigskip

    \item \textbf{How to reduce the logical volume and update the file system?}
    \newline
    Ans.Reducing the size of the logical volume is a complicated task and we have remember some points before reducing the logical volume, otherwise the file system may be damaged .
    Logical volume size cannot be reduced online and it requires downtime because we have to 
    unmount the file system by # \textbf{umount   <file system mount point>command.}
    Check the consistency of the file system by \textbf{# e2fsck   <device or partition name>  command.}
    Reduce the logical volume by # lvreduce   \textbf{-L   - <Size of in MB></dev/vgname/lvname> command.}
    Then update the file system by # resize2fs    </dev/vgname/lvname>
    Finally mount the file system by # mount  -a 
    Example:# umount    <file system mount point>
     # e2fsck   <device or partition name>
      # lvreduce   -L   -<size in MB></dev/vgname/lvname>
     # resize2fs   </dev/vgname/lvname>
     # lvdisplay   </dev/vgname/lvname>	:(to check the size of the logical volume>
     # mount   -a   :(to mount the file system)
     # df    -hT 		:(to check the size of the file system)

     \bigskip
     \bigskip

     \item \textbf{How to move or migrate the logical volume data from one physical volume to another physical volume?}
     \newline
     Ans.There might be a situation where the physical volume might be failing and it is required to replaced. In such case, we need to migrate or move the logical volume data from the failed physical volume new physical volume and isolate (remove) the failed physical volume.
     First access the mount point of the failing physical volume and check the data in it.
     Verify the size of the physical volume by #pvs   or   \textbf{#pvdisplay   </dev/vgname}/lvname>command.
     Unmount the file system of that physical volume by \textbf{# umount   <file system mount point>}
     Add a new physical volume and the size should be same size or higher than that failing physical volume.
     Migrate the physical volume contents to the new physical volume using  \textbf{# pvmove  <old PV>}<new PV>
     Mount back the logical volume, access the mount point and verify the data in it.
     Remove the failed the physical volume by #vgreduce  \textbf{ <vgname><pvname>  command.}
     Example : \begin{itemize}
                   \item # cd   <file system mount point>
                   \item ls 
                   \item # pvs   <pvname>    or   # pvdisplay   <pvname>
                   \item # umount   <file system mount point>
                   \item # pvcreate   <device or partition name>
                   \item #vgextend    <vgname><pvname>
                   \item # pvmove   <old pvname><new pvname>
                   \item # mount   -a
                   \item # vgreduce    <vgname><failed pvname>
                   \item # cd   <file system mount point>
                   \item # ls
                \end{itemize}
    
    \bigskip
    \bigskip

    \item \textbf{How to delete or remove the logical volume?}
    \newline
    Ans.To delete or remove the logical volume, first unmount the file system by \textbf{# umount   <mount point>}Remove the entry in /etc/fstab file.
    Remove the logical volume by \textbf{# lvremove    </dev/vgname/lvname>command.}
    Verify whether the logical volume is removed or not by \textbf{# lvs   or   # lvdisplay   command.}
    Example : 	# umount   <file system mount point>
			# vim /etc/fstab  :(delete the entry of the logical volume)
			Esc+:+wq!	:(save and exit the file)
			# lvremove    </dev/vgname/lvname>
			# lvs    or    # lvdisplay :(to verify whether logical volume is removed or not)
 
    \bigskip
    \bigskip

    \item \textbf{How to delete or remove the volume group?}
    \newline
    Ans.To delete or remove the volume group, first make sure that any logical volume should not be mounted because while removing a volume group it will delete or remove the logical volumes in that volume group.
    Then delete or remove the volume group by # vgremove    <vgname>command.
    Verify whether the volume group is remove or not by # vgs    or    # vgdisplay   command.
    Example : 	# umount     <file system mount point>	:	(to unmount the file system if there is any LV)
			# vim   /etc/fstab 	:(delete the entry of the logical volume)
			Esc+:+wq!	:(save and exit the file)
			# vgremove     <vgname>
			# vgs     or     # vgdisplay :(to verify whether volume group is removed or not)

    \bigskip
    \bigskip

    \item \textbf{How to delete or remove the physical volume?}
    \newline
    Ans. Deleting or removing a physical volume is very simple and the only thing we should check that the physical volume we are going to delete should not belong to any volume group ie., we can only delete or remove the physical volume which is free.
    Then delete or remove the physical volume by \textbf{# pvremove    <pvname>}command Verify whether the physical volume is removed or not by # pvs    or     #pvdisplay    command.
	  Example :  # pvremove   <pvname>
			# pvs    or     #pvdisplay	:(to verify whether the physical volume is removed or not)
 
    \bigskip
    \bigskip

    \item \textbf{How to restore the volume group which is removed mistakenly?}
    \newline
    Ans. First unmount file system by \textbf{# umount   <file system mount point> } command.Check the volume group backup list by # vgcfgrestore    --list   <volume group name>command.
     Then remove the logical volume by \textbf{# lvremove    </dev/vgname/lvname> }command.
     Copy the backup file which is taken backup before removed the volume group from the above backup list and paste it in this command # vgcfgrestore    -f   <paste the above copied file name><vgname>
     The logical volume is created automatically after restoring the volume group but the volume group and logical volumes both will be in inactive state. So, check the state of the volume group by #vgscanand the logical volume state by # lvscan  commands.
     Then activate that volume group by textbf{# vgchange   -ay   <volume group name>commandand activate the logical volume by # lvchange    -ay   <logical volume name>command.
     Mount the logical volume file system by \textbf{# mount   -a}  command
     \textbf{Example : }\begin{itemize}
                           \item # umount    <file system mount point>
                           \item # vgcfgrestore    --list   <volume group name>	(copy the backup file from the list)
                           \item # lvremove    </dev/vgname/lvname>
                           \item# vgcfgrestore    -f   <paste the above copied file><volume group name>
                           \item # vgscan 					(to check the status of the volume group)
                           \item # lvscan						(to check the status of the logical volume)
                           \item# vgchange    -ay   <volume group name>	:(activate the volume group if it is in inactive state)
                           \item# lvchange     -ay   <logical volume name>	:(activate the logical volume if it is in inactive state)
                        \end{itemize}
                        Note:  The option   a   means active VG or LV  and option   y   means  yes.
    
                        
   \bigskip
   \bigskip

   \item \textbf{How to change the volume group name and other parameters?}
   \newline
   Ans. \begin{itemize}
          \item # vgrename    <existing volume group name><new volume group name>  (to rename the volume group)
          \item By default, unlimited logical volumes can be created per volume group. But we can control this limit by
          \item# vgchange    -l   <no.><volume group>	(to limit max. no. of logical volumes to the specified number)
          \item Example :  # vgchange  -l  2  <vgname>	(to limit max. 2 logical volumes cab be created in this volume group)
	        \item # vgchange   -p  <no.><volume group>	(to limit max. no. of physical volumes to the specified number)
	        \item Example : # vgchange  -p  2  <vgname>	(to limit max. 2 physical volumes can be added to this volume group)
	        \item # vgchange   -s  <block size in no.><volume group>		(to change the block size of the volume group)
	        \item Example :  # vgchange   -s   4  <vgname>	(to change the volume group block size to 4MB)
        \end{itemize}
   \bigskip
   \bigskip

   \item \textbf{How to change the logical volume name and other parameters?}
   \newline
   Ans.\begin{itemize}
         \item # lvrename   <existing lvname><new lvname>	(to rename the logical volume)
         \item # lvchange   -pr  <logical volume>	(to put the logical volume into read only mode)
         \item # lvs 				(to see the logical volume permissions)
         \item # lvchange   -prw  <logical volume>	(to put the logical volume into read and write mode) 
      \end{itemize}

    \bigskip
    \bigskip

   \item \textbf{How to disable the volume group and logical volume?}
   \newline
   Ans.\begin{itemize}
          \item # vgchange    -an    <volume group>	:(to disable the volume group)
          # lvchange    -an    <logical volume>	:(to disable the logical volume)
        \end{itemize}

   \bigskip
   \bigskip

   \item \textbf{How to take a backup of the volume group?}
   \newline
   Ans.\begin{itemize}
          \item # vgcfgbackup	:(to take a backup of all volume groups)
          \item # vgcfgbackup   <volume group>	:(to take a backup of the specified volume group)
        \end{{itemize}

   \bigskip
   \bigskip

   \item \textbf{What is the configuration file of the logical volume?}
   \newline
   Ans.# cat  /etc/lvm/lvm.conf 		(to see the contents of the LVM configuration file)
   
   \bigskip
   \bigskip

   \item \textbf{What are the locations of the logical volume and volume groups?}
   \newline
   Ans. \begin{itemize}
           \item # cd  /etc/lvm/backup		:(the logical volumes backup location)
           \item # cd  /etc/lvm/archive		(:the volume groups backup location)
        \end{itemize}

   \bigskip
   \bigskip

   \item \textbf{How to know the current version of the LVM package?}
   \newline
   Ans.# rpm  -qa   lvm*	:(to know the current version of the LVM package)

   \bigskip
   \bigskip

   \item \textbf{What are the attributes of the volume group?}
   \newline
   Ans.# vgs				(to see the attributes of the volume group)
   \newline
   [ The attributes are  w ---->  writable          z ---->  extendable            n ---->  normal ]
   # vgs   -v 				(to check the UUID of the volume group)
 
  \bigskip
  \bigskip

  \item \textbf{How to extend the logical volume to max. disk space and half of the disk space?}
  \newline
   Ans. # lvextend    -l  +100% FREE   <logical volume>	(to extend the logical volume by adding the volume group's  	   total available space)
   \newline
   # lvextend    -l  50%   <vgname><lvname>		(to extend the logical volume by adding the 50% free space    of the volume group)


   \bigskip
   \bigskip

   \item \textbf{How to check on which physical volume the data is writing in the logical volume?}
   \newline
   Ans. # lvdisplay    -m  :( to check  on which physical volume the data is currently writing from all 				logical volumes)
   # lvdisplay   -m   <lvname>	:(to check on which physical volume the data is writing from the Specified   logical volume)

   \bigskip
   \bigskip

   \item \textbf{How many types of file systems available?}
   \newline
   Ans. \begin{itemize}
           \item ext2 :Second extended file system (default in RHEL - 3 & 4)
           \item ext3 :Third extended file system (default in RHEL - 5)
           \item  ext4 :Fourth extended file system (default in RHEL - 6)
           \item  xfs :Extended file system (default in RHEL - 7)
           \item ufs  :Unix file system  (default in Solaris)	
           \item jfs : Journal file system  (default in IBM-AIX)
           \item hfs  : High performance file system (default in HP-UX)
           \item vxfs : Veritas file system
           \item procfs : Process file system (temporary)
           \item tempfs :Temporary file system (temporary)
           \item cdfs : Compact disk file system
           \item hdfs : DVD file system
           \item iso9660 :  To read the CD/DVD.iso image format files in Linux
        \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{How to scan and detect the luns over the network?}
    \newline
    Ans.# ls  /sys/class/fc_host	:(to check the available fibre channels)
      # echo  "---"   >  /sys/class/scsi_host/<lun no.>/scan:(to scan and detect the luns over the network)
    
    \bigskip
    \bigskip

    \item \textbf{How to mount a pen drive in Linux?}
    \newline
    Ans.\begin{itemize}
           \item # lsusb or # fdisk -l  :(to know the pen drive name)
           \item # mkdir  /mnt/pendrive	:(to create a mount point for pen drive)
           \item# mount <pen drive name><mount point> :( to mount the pen drive on the above created mount point)
           \item # cd /mnt/pendrive :(to access the pen drive)
        \end{itemize}
    
    \bigskip
    \bigskip

    \item \textbf{How to mount a CD/DVD ROM drives in Linux?}
    \newline
    Ans.The CD/DVD ROM device name in Linux is  /dev/cdrom
        \begin{itemize}
          \item # mkdir /mnt/mycdrom	:(to create the mount point for CD/DVD)
          \item # mount /dev/cdrom /mnt/mycdrom	:(to mount the CD/DVD on the above created mount point)
          \item # cd /mnt/mycdrom :(to access the CD/DVD ROM drives)
    
    \bigskip
    \bigskip

    \item \textbf{How to mount the  " .iso "  image files in Linux?}
    \newline
    Ans.  \begin{itemize}
            \item # mount   -t   iso9660    /root/rhel6.iso   /iso  -o  ro, loop	:(to mount the .iso image files)
	          \item  # cdrecord   /root/Desktop/rhel6.iso 	: (to write the CD/DVD ROM. Before executing this 
            \item command put the empty CD/DVD into CD/DVD drive)
	          \item # eject  		:	(to eject the CD/DVD drive tray)
	          \item # eject   -t	:	(to insert and close the CD/DVD drive tray)
           \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{What is RAID? What is the use of the RAID and how many types of RAIDs available?}
    \newline
    Ans.RAID stands for Redundant Array of Independent Disks.It provides fault tolerance, load balancing using stripping, mirroring and parity concepts.
        There are mainly two types of RAIDs available.
        \begin{itemize}
          \item Hardware RAID :(Depends on vendors and also more expensive)
          \item  Software RAID :(Does not depends on vendors and less expensive when compared to Hardware 
        \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{How many types of software RAIDs available and their requirements?}
    \newline
    Ans. \begin{enumerate}
             \item RAID - 0    ----	Stripping    ----	Minimum 2 disks required
             \item   RAID - 1    ----	Mirroring   ----	Minimum 2 disks required
             \item  RAID - (1+0)  ---	Mirroring + Stripping ----  Minimum 4 disks required
             \item  RAID - (0+1)  ---	Stripping + Mirroring ----  Minimum 4 disks required
             \item  RAID - 5    ----	Stripping with parity ----	  Minimum 3 disks required
          \end{enumerate}

    \bigskip
    \bigskip

    \item \textbf{How to configure RAID - 0 in Linux?}
    \newline
    Ans.To configure RAID - 0, minimum 2 disks are required and the partition id is "fd".Reading and writing is very fast. So, it produces high performance.
    if one disk is failed we cannot recover the data.
    So, there is no redundancy and fault tolerance in RAID - 0.
    Example :  For example if the data is 1, 2, 3, 4, 5 and 6 then ....
    \newline
    Disk - 1		         Disk - 2
    If the Disk - 1 is /dev/sdb   and  the Disk - 2 is  /dev/sdc   then,
    \begin{itemize}
      \item # mdadm   -Cv  /dev/md0   -n  2   /dev/sdb    /dev/sdc   -l  0	(to create the RAID - 0 using disk - 1 and disk - 2)
      \item # cat  /proc/mdstat				(to check the RAID - 0 is created or not)
      \item# mkfs.ext4   /dev/md0  				(to create the ext4 file system on the RAID - 0)
      \item# mkdir  /mnt/raid0				(to create the RAID - 0 mount point)
      \item# mount   /dev/md0    /mnt/raid0			(to mount RAID - 0 on the mount point)
      \item# mdadm   -D  /dev/md0				(to see the details of the RAID - 0 partition)
      \item# mdadm    /dev/md0    -f   /dev/sdb		(to failed the disk manually)
      \item# mdadm   /dev/md0    -r   /dev/sdb		(to remove the above failed disk)
      \item# mdadm   /dev/md0    -a   /dev/sdd		(to add the new disk in place of failed disk)
      \item# umount   /mnt/raid0				(to unmount the raid file system)
      \item# mdadm   --stop   /dev/md0			(to stop the RAID - 0 volume)
      \item# mdadm   /dev/md0   --add   /dev/sde		(to add third disk to the RAID - 0 volume)
      \item# mdadm    --grow   /dev/md0   --raid_device=3	(to grow the RAID - 0 file system)
    \end{itemize} 

    \bigskip
    \bigskip

    \item \textbf{How to configure RAID - 1 in Linux?}
    \newline
    Ans. To configure RAID - 1, minimum 2 disks are required and the partition id is "fd".
    In this the same data will be written on 2 disks ie., exact copy on both the disks.
    if one disk is failed we can recover the data from another disk.
    So, there is a high availability, redundancy and fault tolerance in RAID - 1.
    In this writing speed is slow compared to RAID - 0.
    Example :  For example if the data is 1, 2, 3, 4, 5 and 6 then ....
    \newline
    If the Disk - 1 is /dev/sdb   and  the Disk - 2 is  /dev/sdc   then,
      \begin{itemize}
        \item # mdadm   -Cv  /dev/md0   -n  2   /dev/sdb    /dev/sdc   -l  1	(to create the RAID - 1 using disk - 1 and disk - 2)
        \item# cat  /proc/mdstat			(to check the RAID - 1 is created or not)
        \item# mkfs.ext4   /dev/md0  			(to create the ext4 file system on the RAID - 1)
        \item# mkdir  /mnt/raid1			(to create the RAID - 1 mount point)
        \item# mount   /dev/md0    /mnt/raid1		(to mount RAID - 1 on the mount point)
        \item# mdadm   -D  /dev/md0			(to see the details of the RAID - 1 partition)
        \item# mdadm    /dev/md0    -f   /dev/sdb	(to failed the disk manually)
        \item# mdadm   /dev/md0    -r   /dev/sdb	(to remove the above failed disk)
        \item# mdadm   /dev/md0    -a   /dev/sdd	(to add the new disk in place of failed disk)
        \item# umount   /mnt/raid1			(to unmount the raid file system)
        \item# mdadm   --stop   /dev/md0		(to stop the RAID - 1 volume)
        \item# mdadm   /dev/md0   --add   /dev/sde	(to add third disk to the RAID - 1 volume)
        \item# mdadm    --grow   /dev/md0   --raid_device=3	(to grow the RAID - 1 file system)
      \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{How to configure RAID - 5 in Linux?}
    \newline
    Ans.To configure RAID - 5, minimum 3 disks are required and the partition id is "fd".
    In every disk approximately 25 - 30% of space is reserved for parity.
    Reading and writing is very fast. So, it produces high performance.
    This is used Stripping with parity concept.
    if one disk is failed we can recover the data using remaining two disks and parity.
    If two disks are failed, then we cannot recover the data.
    So, there is no redundancy and fault tolerance in RAID - 5.
    Example :  For example if the data is 1, 2, 3, 4, 5 and 6 then ....
    \newline
             Disk - 1	Disk - 2		  Disk - 3
             If the Disk - 1 is /dev/sdb,   the Disk - 2 is  /dev/sdc  and  Disk - 3 is /dev/sddthen,
     \begin{itemize}
       \item # mdadm   -Cv  /dev/md0   -n  2   /dev/sdb    /dev/sdc   -l  5	(to create the RAID - 5 using disks - 1, 2  and 3)
       \item# cat  /proc/mdstat			(to check the RAID - 5 is created or not)
       \item# mkfs.ext4   /dev/md0  			(to create the ext4 file system on the RAID - 5)
       \item# mkdir  /mnt/raid5			(to create the RAID - 5 mount point)
       \item# mount   /dev/md0    /mnt/raid5		(to mount RAID - 5 on the mount point)
       \item# mdadm   -D  /dev/md0			(to see the details of the RAID - 5 partition)
       \item# mdadm    /dev/md0    -f   /dev/sdb	(to failed the disk manually)
       \item# mdadm   /dev/md0    -r   /dev/sdb	(to remove the above failed disk)
       \item# mdadm   /dev/md0    -a   /dev/sde	(to add the new disk in place of failed disk)
       \item# umount   /mnt/raid5			(to unmount the raid file system)
       \item# mdadm   --stop   /dev/md0		(to stop the RAID - 5 volume)
       \item# mdadm   /dev/md0   --add   /dev/sdf	(to add fourth disk to the RAID - 5 volume)
       \item# mdadm    --grow   /dev/md0   --raid_device=4	(to grow the RAID - 5 file system)
     \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{What are the main advantages of RAID - 5}
    \newline
    Ans.RAID - 5 uses Stripping with parity and requires only three disks. Because of Stripping the data reading and 	writing will be fast.And by usingparity we can recover the data if one of the three disks failed. So, the main 	advantage of RAID - 5 we can get fast writing, reading and also redundancy fault tolerance with less expensive.

    \bigskip
    \bigskip

    \item \textbf{How will you troubleshoot if one of the eight disks failed in LVM?}
    \newline
    Ans. First umount the file system and add the new disk with same size of the failed disk to the volume group. 	Then move the data from failed physical volume to newly added physical volume and then remove the failed physical volume from the volume group. And finally mount the file system.
 
    \bigskip
    \bigskip

    \item \textbf{What is pvmove and when it is used in LVM?}
    \newline
    Ans.The pvmove command is used to move the data from failed physical volume to newly added physical volume. 	This command is used when one of the physical volume is failed in the LVM.

    \bigskip
    \bigskip

    \item \textbf{How to inform the client and then troubleshoot if the disk is full?}
    \newline
    Ans.First check which files are accessing more disk space by \textbf{#du -h } |sort  - r command. if any temporary and junk files are present remove them from the disk to make a room for new or updated data. Then inform the actual 	situation to the client, take the permission from the client to get the lun from storage and extend the file system 	by adding that lun to the LVM.
    
    \bigskip
    \bigskip

    \item \textbf{Did you work on storage?}
    \newline
    Ans.Actually I did not work on storage but I know the procedure how to export the lun from storage to client using iSCSI target. Then scan that lun at cleint side and add the lun to the LVM. I also know the storage hardware from 	Emc square, Netapp and others. And I am dreaming to work on storage, cloud and virtualization.
    
    \bigskip
    \bigskip

    \item \textbf{I have four disks each 1TB in RAID - (1+0). So, total how much disk space can I utilize in that RAID – 
    (1+0)?}
    \newline
    Ans.RAID - (1+0) means Mirroring + Stripping. It requires 4 disks, ie., 2 disks for mirroring and remaining 2 disks for 	stripping. And 5 - 10% disk space is used for superblock information. So, finally we can utilize 2TB - 2TB X 10% 	disk space in that RAID - (1+0).
    
    \bigskip
    \bigskip

    \item \textbf{If two disks failed in RAID - (1+0), can we recover the data?}
    \newline
    Ans.The RAID - (1+0) requires minimum 4 disks and it uses Mirroring + Stripping. If one disk is failed we can 
    recover 	the data, but if two disks are failed we cannot recover the data.
    
    \bigskip
    \bigskip

    \item \textbf{How many types of disk space issues can we normally get?}
    \newline
    Ans . \begin{itemize}
              \item Disk is full.
              \item  Disk is failing or failed.
              \item  File system corrupted or crashed.
              \item  O/S is not recognizing the remote luns when scanning, ...etc.,
          \end{itemize}

    \bigskip
    \bigskip

    \item \textbf{What is a link file and how many types?}
    \newline
    Ans. Link file is a short cut file to the original file. Creating and removing  (deleting)  inks  between two files is known 	as managing links. There are two types of links files available in Linux.
      \begin{itemize}
        \item Soft link
        \item 	Hard link
      \end{itemize} 
   
    \bigskip
    \bigskip

    
    
    
      

    

    
    


  
 
   
       
   

          
    
        


    


    
    
    



        
          
  
    






    

           
       
     
    

                    
                         
    








        
        








    
    







        

    














     

                     


 


    


    


    



\end{enumerate}
